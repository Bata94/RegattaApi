// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: meldung.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const abmeldung = `-- name: Abmeldung :exec
UPDATE
  meldung
SET
  abgemeldet = true,
  abteilung = 0,
  bahn = 0
WHERE
  uuid = $1
`

func (q *Queries) Abmeldung(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, abmeldung, argUuid)
	return err
}

const checkMedlungSetzung = `-- name: CheckMedlungSetzung :one
SELECT uuid, abteilung, bahn FROM meldung
WHERE abteilung != 0 AND bahn != 0 LIMIT 1
`

type CheckMedlungSetzungRow struct {
	Uuid      uuid.UUID `json:"uuid"`
	Abteilung int32     `json:"abteilung"`
	Bahn      int32     `json:"bahn"`
}

func (q *Queries) CheckMedlungSetzung(ctx context.Context) (CheckMedlungSetzungRow, error) {
	row := q.db.QueryRow(ctx, checkMedlungSetzung)
	var i CheckMedlungSetzungRow
	err := row.Scan(&i.Uuid, &i.Abteilung, &i.Bahn)
	return i, err
}

const createMeldung = `-- name: CreateMeldung :one
INSERT INTO meldung (
  uuid,
  verein_uuid,
  rennen_uuid,
  drv_revision_uuid,
  abgemeldet,
  kosten,
  typ,
  bemerkung
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dnf, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, rechnungs_nummer, verein_uuid, rennen_uuid
`

type CreateMeldungParams struct {
	Uuid            uuid.UUID   `json:"uuid"`
	VereinUuid      uuid.UUID   `json:"verein_uuid"`
	RennenUuid      uuid.UUID   `json:"rennen_uuid"`
	DrvRevisionUuid uuid.UUID   `json:"drv_revision_uuid"`
	Abgemeldet      bool        `json:"abgemeldet"`
	Kosten          int32       `json:"kosten"`
	Typ             string      `json:"typ"`
	Bemerkung       pgtype.Text `json:"bemerkung"`
}

func (q *Queries) CreateMeldung(ctx context.Context, arg CreateMeldungParams) (Meldung, error) {
	row := q.db.QueryRow(ctx, createMeldung,
		arg.Uuid,
		arg.VereinUuid,
		arg.RennenUuid,
		arg.DrvRevisionUuid,
		arg.Abgemeldet,
		arg.Kosten,
		arg.Typ,
		arg.Bemerkung,
	)
	var i Meldung
	err := row.Scan(
		&i.Uuid,
		&i.DrvRevisionUuid,
		&i.Typ,
		&i.Bemerkung,
		&i.Abgemeldet,
		&i.Dns,
		&i.Dnf,
		&i.Dsq,
		&i.ZeitnahmeBemerkung,
		&i.StartNummer,
		&i.Abteilung,
		&i.Bahn,
		&i.Kosten,
		&i.RechnungsNummer,
		&i.VereinUuid,
		&i.RennenUuid,
	)
	return i, err
}

const getAllMeldung = `-- name: GetAllMeldung :many
SELECT uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dnf, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, rechnungs_nummer, verein_uuid, rennen_uuid FROM meldung
ORDER BY start_nummer ASC
`

func (q *Queries) GetAllMeldung(ctx context.Context) ([]Meldung, error) {
	rows, err := q.db.Query(ctx, getAllMeldung)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Meldung{}
	for rows.Next() {
		var i Meldung
		if err := rows.Scan(
			&i.Uuid,
			&i.DrvRevisionUuid,
			&i.Typ,
			&i.Bemerkung,
			&i.Abgemeldet,
			&i.Dns,
			&i.Dnf,
			&i.Dsq,
			&i.ZeitnahmeBemerkung,
			&i.StartNummer,
			&i.Abteilung,
			&i.Bahn,
			&i.Kosten,
			&i.RechnungsNummer,
			&i.VereinUuid,
			&i.RennenUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMeldungForVerein = `-- name: GetAllMeldungForVerein :many
SELECT
  meldung.uuid, meldung.drv_revision_uuid, meldung.typ, meldung.bemerkung, meldung.abgemeldet, meldung.dns, meldung.dnf, meldung.dsq, meldung.zeitnahme_bemerkung, meldung.start_nummer, meldung.abteilung, meldung.bahn, meldung.kosten, meldung.rechnungs_nummer, meldung.verein_uuid, meldung.rennen_uuid,
  rennen.uuid, rennen.sort_id, rennen.nummer, rennen.bezeichnung, rennen.bezeichnung_lang, rennen.zusatz, rennen.leichtgewicht, rennen.geschlecht, rennen.bootsklasse, rennen.bootsklasse_lang, rennen.altersklasse, rennen.altersklasse_lang, rennen.tag, rennen.wettkampf, rennen.kosten_eur, rennen.rennabstand, rennen.startzeit,
  athlet.uuid, athlet.vorname, athlet.name, athlet.geschlecht, athlet.jahrgang, athlet.gewicht, athlet.startberechtigt, athlet.verein_uuid,
  link_meldung_athlet.rolle, link_meldung_athlet.position
FROM
  meldung
JOIN
  rennen
ON
  rennen.uuid = meldung.rennen_uuid
JOIN
  link_meldung_athlet
ON
  link_meldung_athlet.meldung_uuid = meldung.uuid
JOIN
  athlet
ON
  link_meldung_athlet.athlet_uuid = athlet.uuid
WHERE
  meldung.verein_uuid = $1
ORDER BY
  rennen.sort_id, meldung.abteilung, meldung.bahn, link_meldung_athlet.rolle, link_meldung_athlet.position
`

type GetAllMeldungForVereinRow struct {
	Meldung  Meldung `json:"meldung"`
	Rennen   Rennen  `json:"rennen"`
	Athlet   Athlet  `json:"athlet"`
	Rolle    Rolle   `json:"rolle"`
	Position int32   `json:"position"`
}

func (q *Queries) GetAllMeldungForVerein(ctx context.Context, vereinUuid uuid.UUID) ([]GetAllMeldungForVereinRow, error) {
	rows, err := q.db.Query(ctx, getAllMeldungForVerein, vereinUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMeldungForVereinRow{}
	for rows.Next() {
		var i GetAllMeldungForVereinRow
		if err := rows.Scan(
			&i.Meldung.Uuid,
			&i.Meldung.DrvRevisionUuid,
			&i.Meldung.Typ,
			&i.Meldung.Bemerkung,
			&i.Meldung.Abgemeldet,
			&i.Meldung.Dns,
			&i.Meldung.Dnf,
			&i.Meldung.Dsq,
			&i.Meldung.ZeitnahmeBemerkung,
			&i.Meldung.StartNummer,
			&i.Meldung.Abteilung,
			&i.Meldung.Bahn,
			&i.Meldung.Kosten,
			&i.Meldung.RechnungsNummer,
			&i.Meldung.VereinUuid,
			&i.Meldung.RennenUuid,
			&i.Rennen.Uuid,
			&i.Rennen.SortID,
			&i.Rennen.Nummer,
			&i.Rennen.Bezeichnung,
			&i.Rennen.BezeichnungLang,
			&i.Rennen.Zusatz,
			&i.Rennen.Leichtgewicht,
			&i.Rennen.Geschlecht,
			&i.Rennen.Bootsklasse,
			&i.Rennen.BootsklasseLang,
			&i.Rennen.Altersklasse,
			&i.Rennen.AltersklasseLang,
			&i.Rennen.Tag,
			&i.Rennen.Wettkampf,
			&i.Rennen.KostenEur,
			&i.Rennen.Rennabstand,
			&i.Rennen.Startzeit,
			&i.Athlet.Uuid,
			&i.Athlet.Vorname,
			&i.Athlet.Name,
			&i.Athlet.Geschlecht,
			&i.Athlet.Jahrgang,
			&i.Athlet.Gewicht,
			&i.Athlet.Startberechtigt,
			&i.Athlet.VereinUuid,
			&i.Rolle,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeldungMinimal = `-- name: GetMeldungMinimal :one
SELECT uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dnf, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, rechnungs_nummer, verein_uuid, rennen_uuid FROM meldung
WHERE uuid = $1 LIMIT 1
`

func (q *Queries) GetMeldungMinimal(ctx context.Context, argUuid uuid.UUID) (Meldung, error) {
	row := q.db.QueryRow(ctx, getMeldungMinimal, argUuid)
	var i Meldung
	err := row.Scan(
		&i.Uuid,
		&i.DrvRevisionUuid,
		&i.Typ,
		&i.Bemerkung,
		&i.Abgemeldet,
		&i.Dns,
		&i.Dnf,
		&i.Dsq,
		&i.ZeitnahmeBemerkung,
		&i.StartNummer,
		&i.Abteilung,
		&i.Bahn,
		&i.Kosten,
		&i.RechnungsNummer,
		&i.VereinUuid,
		&i.RennenUuid,
	)
	return i, err
}

const setMeldungRechnungsNummer = `-- name: SetMeldungRechnungsNummer :exec
UPDATE meldung
SET rechnungs_nummer = $2
WHERE uuid = $1
`

type SetMeldungRechnungsNummerParams struct {
	Uuid            uuid.UUID   `json:"uuid"`
	RechnungsNummer pgtype.Text `json:"rechnungs_nummer"`
}

func (q *Queries) SetMeldungRechnungsNummer(ctx context.Context, arg SetMeldungRechnungsNummerParams) error {
	_, err := q.db.Exec(ctx, setMeldungRechnungsNummer, arg.Uuid, arg.RechnungsNummer)
	return err
}

const updateMeldungSetzung = `-- name: UpdateMeldungSetzung :exec
UPDATE meldung
SET abteilung = $2, bahn = $3
WHERE uuid = $1
`

type UpdateMeldungSetzungParams struct {
	Uuid      uuid.UUID `json:"uuid"`
	Abteilung int32     `json:"abteilung"`
	Bahn      int32     `json:"bahn"`
}

func (q *Queries) UpdateMeldungSetzung(ctx context.Context, arg UpdateMeldungSetzungParams) error {
	_, err := q.db.Exec(ctx, updateMeldungSetzung, arg.Uuid, arg.Abteilung, arg.Bahn)
	return err
}

const updateStartNummer = `-- name: UpdateStartNummer :exec
UPDATE meldung
SET start_nummer = $2
WHERE uuid = $1
`

type UpdateStartNummerParams struct {
	Uuid        uuid.UUID `json:"uuid"`
	StartNummer int32     `json:"start_nummer"`
}

func (q *Queries) UpdateStartNummer(ctx context.Context, arg UpdateStartNummerParams) error {
	_, err := q.db.Exec(ctx, updateStartNummer, arg.Uuid, arg.StartNummer)
	return err
}
