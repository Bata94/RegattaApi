// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: meldung.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const checkMedlungSetzung = `-- name: CheckMedlungSetzung :one
SELECT uuid, abteilung, bahn FROM meldung
WHERE abteilung != 0 AND bahn != 0 LIMIT 1
`

type CheckMedlungSetzungRow struct {
	Uuid      uuid.UUID `json:"uuid"`
	Abteilung *int32    `json:"abteilung"`
	Bahn      *int32    `json:"bahn"`
}

func (q *Queries) CheckMedlungSetzung(ctx context.Context) (*CheckMedlungSetzungRow, error) {
	row := q.db.QueryRow(ctx, checkMedlungSetzung)
	var i CheckMedlungSetzungRow
	err := row.Scan(&i.Uuid, &i.Abteilung, &i.Bahn)
	return &i, err
}

const createMeldung = `-- name: CreateMeldung :one
INSERT INTO meldung (
  uuid,
  verein_uuid,
  rennen_uuid,
  drv_revision_uuid,
  abgemeldet,
  kosten,
  typ,
  bemerkung
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, verein_uuid, rennen_uuid
`

type CreateMeldungParams struct {
	Uuid            uuid.UUID `json:"uuid"`
	VereinUuid      uuid.UUID `json:"verein_uuid"`
	RennenUuid      uuid.UUID `json:"rennen_uuid"`
	DrvRevisionUuid uuid.UUID `json:"drv_revision_uuid"`
	Abgemeldet      *bool     `json:"abgemeldet"`
	Kosten          int32     `json:"kosten"`
	Typ             string    `json:"typ"`
	Bemerkung       *string   `json:"bemerkung"`
}

func (q *Queries) CreateMeldung(ctx context.Context, arg CreateMeldungParams) (*Meldung, error) {
	row := q.db.QueryRow(ctx, createMeldung,
		arg.Uuid,
		arg.VereinUuid,
		arg.RennenUuid,
		arg.DrvRevisionUuid,
		arg.Abgemeldet,
		arg.Kosten,
		arg.Typ,
		arg.Bemerkung,
	)
	var i Meldung
	err := row.Scan(
		&i.Uuid,
		&i.DrvRevisionUuid,
		&i.Typ,
		&i.Bemerkung,
		&i.Abgemeldet,
		&i.Dns,
		&i.Dsq,
		&i.ZeitnahmeBemerkung,
		&i.StartNummer,
		&i.Abteilung,
		&i.Bahn,
		&i.Kosten,
		&i.VereinUuid,
		&i.RennenUuid,
	)
	return &i, err
}

const getAllMeldung = `-- name: GetAllMeldung :many
SELECT uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, verein_uuid, rennen_uuid FROM meldung
ORDER BY start_nummer ASC
`

func (q *Queries) GetAllMeldung(ctx context.Context) ([]*Meldung, error) {
	rows, err := q.db.Query(ctx, getAllMeldung)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Meldung
	for rows.Next() {
		var i Meldung
		if err := rows.Scan(
			&i.Uuid,
			&i.DrvRevisionUuid,
			&i.Typ,
			&i.Bemerkung,
			&i.Abgemeldet,
			&i.Dns,
			&i.Dsq,
			&i.ZeitnahmeBemerkung,
			&i.StartNummer,
			&i.Abteilung,
			&i.Bahn,
			&i.Kosten,
			&i.VereinUuid,
			&i.RennenUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeldungMinimal = `-- name: GetMeldungMinimal :one
SELECT uuid, drv_revision_uuid, typ, bemerkung, abgemeldet, dns, dsq, zeitnahme_bemerkung, start_nummer, abteilung, bahn, kosten, verein_uuid, rennen_uuid FROM meldung
WHERE uuid = $1 LIMIT 1
`

func (q *Queries) GetMeldungMinimal(ctx context.Context, argUuid uuid.UUID) (*Meldung, error) {
	row := q.db.QueryRow(ctx, getMeldungMinimal, argUuid)
	var i Meldung
	err := row.Scan(
		&i.Uuid,
		&i.DrvRevisionUuid,
		&i.Typ,
		&i.Bemerkung,
		&i.Abgemeldet,
		&i.Dns,
		&i.Dsq,
		&i.ZeitnahmeBemerkung,
		&i.StartNummer,
		&i.Abteilung,
		&i.Bahn,
		&i.Kosten,
		&i.VereinUuid,
		&i.RennenUuid,
	)
	return &i, err
}
