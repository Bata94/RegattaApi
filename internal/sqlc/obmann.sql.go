// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: obmann.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createObmann = `-- name: CreateObmann :one
INSERT INTO obmann (
  uuid,
  verein_uuid,
  name,
  email,
  phone
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING uuid, name, email, phone, verein_uuid
`

type CreateObmannParams struct {
	Uuid       uuid.UUID   `json:"uuid"`
	VereinUuid uuid.UUID   `json:"verein_uuid"`
	Name       pgtype.Text `json:"name"`
	Email      pgtype.Text `json:"email"`
	Phone      pgtype.Text `json:"phone"`
}

func (q *Queries) CreateObmann(ctx context.Context, arg CreateObmannParams) (Obmann, error) {
	row := q.db.QueryRow(ctx, createObmann,
		arg.Uuid,
		arg.VereinUuid,
		arg.Name,
		arg.Email,
		arg.Phone,
	)
	var i Obmann
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.VereinUuid,
	)
	return i, err
}

const getAllObmann = `-- name: GetAllObmann :many
SELECT uuid, name, email, phone, verein_uuid FROM obmann
ORDER BY name ASC
`

func (q *Queries) GetAllObmann(ctx context.Context) ([]Obmann, error) {
	rows, err := q.db.Query(ctx, getAllObmann)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Obmann{}
	for rows.Next() {
		var i Obmann
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.VereinUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObmannMinimal = `-- name: GetObmannMinimal :one
SELECT uuid, name, email, phone, verein_uuid FROM obmann
WHERE uuid = $1 LIMIT 1
`

func (q *Queries) GetObmannMinimal(ctx context.Context, argUuid uuid.UUID) (Obmann, error) {
	row := q.db.QueryRow(ctx, getObmannMinimal, argUuid)
	var i Obmann
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.VereinUuid,
	)
	return i, err
}
